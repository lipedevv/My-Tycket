#!/bin/bash

# WhatiTicket Plus - Instalador Unificado
# Combina todas as funcionalidades dos instaladores existentes
# VersÃ£o: 2.0

# reset shell colors
tput init

echo "ğŸš€ WhatiTicket Plus - Instalador Unificado"
echo "=========================================="
echo "âœ¨ Recursos incluÃ­dos:"
echo "   â€¢ InstalaÃ§Ã£o padrÃ£o com modo seguro"
echo "   â€¢ Backup automÃ¡tico e rollback"
echo "   â€¢ ValidaÃ§Ã£o pÃ³s-instalaÃ§Ã£o"
echo "   â€¢ Scripts de manutenÃ§Ã£o"
echo "   â€¢ Compatibilidade Ubuntu 22/24 LTS"
echo ""

# https://stackoverflow.com/questions/59895/how-to-get-the-source-directory-of-a-bash-script-from-within-the-script-itself
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  PROJECT_ROOT="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$PROJECT_ROOT/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
PROJECT_ROOT="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"

# required imports
source "${PROJECT_ROOT}"/variables/manifest.sh
source "${PROJECT_ROOT}"/utils/manifest.sh

# Load Ubuntu 22/24 compatible system functions
if [[ -f "${PROJECT_ROOT}"/lib/_system_ubuntu22.sh ]]; then
  source "${PROJECT_ROOT}"/lib/_system_ubuntu22.sh
else
  echo "âš ï¸ Usando sistema original (pode ter problemas no Ubuntu 22+)"
  source "${PROJECT_ROOT}"/lib/_system.sh
fi

# Load other functions
source "${PROJECT_ROOT}"/lib/_backend.sh
source "${PROJECT_ROOT}"/lib/_frontend.sh
source "${PROJECT_ROOT}"/lib/_inquiry.sh

# user configs file
if [[ ! -e "${PROJECT_ROOT}"/config ]]; then
  cat << EOF > "${PROJECT_ROOT}"/config
deploy_password=${deploy_password}
mysql_root_password=${mysql_root_password}
db_pass=${db_pass}
EOF
fi

# this file has passwords
sudo su - root <<EOF
chown root:root "${PROJECT_ROOT}"/config
chmod 700 "${PROJECT_ROOT}"/config
EOF
source "${PROJECT_ROOT}"/config

# ğŸ”§ CONFIGURAÃ‡ÃƒO DO INSTALADOR
INSTALL_MODE=""
UPDATE_MODE=false
SAFE_MODE=true
AUTO_BACKUP=true

show_menu() {
    echo ""
    echo "ğŸ“‹ Selecione o modo de instalaÃ§Ã£o:"
    echo "1) ğŸš€ InstalaÃ§Ã£o PadrÃ£o (Recomendado)"
    echo "2) ğŸ”’ InstalaÃ§Ã£o Segura (Com validaÃ§Ã£o e backup)"
    echo "3) ğŸ”„ Atualizar InstalaÃ§Ã£o Existente"
    echo "4) ğŸ› ï¸ Modo AvanÃ§ado (ConfiguraÃ§Ã£o manual)"
    echo "5) â“ Sair"
    echo ""
    read -p "Escolha uma opÃ§Ã£o [1-5]: " -n 1 -r
    echo ""

    case $REPLY in
        1)
            INSTALL_MODE="standard"
            SAFE_MODE=false
            AUTO_BACKUP=false
            ;;
        2)
            INSTALL_MODE="safe"
            SAFE_MODE=true
            AUTO_BACKUP=true
            ;;
        3)
            INSTALL_MODE="update"
            UPDATE_MODE=true
            SAFE_MODE=true
            AUTO_BACKUP=true
            ;;
        4)
            INSTALL_MODE="advanced"
            configure_advanced
            ;;
        5)
            echo "ğŸ‘‹ Saindo do instalador..."
            exit 0
            ;;
        *)
            echo "âŒ OpÃ§Ã£o invÃ¡lida! Tente novamente."
            show_menu
            ;;
    esac
}

configure_advanced() {
    echo "âš™ï¸ ConfiguraÃ§Ã£o AvanÃ§ada"
    echo "======================="

    read -p "ğŸ”’ Habilitar modo seguro? (s/N): " -n 1 -r
    echo
    [[ $REPLY =~ ^[Ss]$ ]] && SAFE_MODE=true || SAFE_MODE=false

    read -p "ğŸ’¾ Criar backup automÃ¡tico? (S/n): " -n 1 -r
    echo
    [[ $REPLY =~ ^[Nn]$ ]] && AUTO_BACKUP=false || AUTO_BACKUP=true

    read -p "ğŸš€ Pular validaÃ§Ãµes de compatibilidade? (s/N): " -n 1 -r
    echo
    [[ $REPLY =~ ^[Ss]$ ]] && SKIP_VALIDATION=true || SKIP_VALIDATION=false

    echo ""
    echo "âœ… ConfiguraÃ§Ã£o concluÃ­da!"
    echo "   â€¢ Modo Seguro: $SAFE_MODE"
    echo "   â€¢ Backup AutomÃ¡tico: $AUTO_BACKUP"
    echo "   â€¢ Pular ValidaÃ§Ãµes: $SKIP_VALIDATION"
    echo ""
    read -p "Pressione ENTER para continuar..."
}

# ğŸ” FUNÃ‡Ã•ES DE SEGURANÃ‡A E VALIDAÃ‡ÃƒO
check_existing_installation() {
    if [[ "$INSTALL_MODE" == "standard" ]] && [[ "$SAFE_MODE" == "false" ]]; then
        echo "âš¡ Modo padrÃ£o - pulando verificaÃ§Ãµes de seguranÃ§a"
        return 0
    fi

    echo "ğŸ” Verificando instalaÃ§Ã£o existente..."

    # Verificar se jÃ¡ existe database
    if sudo -u postgres psql -lqt | grep -qw "${instancia_add}"; then
        echo "âš ï¸ Database '${instancia_add}' jÃ¡ existe!"

        if [[ "$INSTALL_MODE" != "update" ]]; then
            # Verificar se tem dados
            table_count=$(sudo -u postgres psql -d "${instancia_add}" -tAc "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';")
            if [[ $table_count -gt 0 ]]; then
                echo "âš ï¸ Database contÃ©m ${table_count} tabelas com dados!"

                if [[ "$SAFE_MODE" == "true" ]]; then
                    read -p "â“ Deseja continuar mesmo assim? Isto pode causar perda de dados! (s/N): " -n 1 -r
                    echo
                    if [[ ! $REPLY =~ ^[Ss]$ ]]; then
                        echo "âŒ InstalaÃ§Ã£o cancelada para proteger dados existentes."
                        exit 1
                    fi
                fi
            fi
        fi
    fi

    # Verificar se o diretÃ³rio jÃ¡ existe
    if [[ -d "/home/deploy/${instancia_add}" ]]; then
        echo "âš ï¸ DiretÃ³rio da instÃ¢ncia jÃ¡ existe: /home/deploy/${instancia_add}"

        # Verificar se tem processo PM2 rodando
        if pm2 list | grep -q "${instancia_add}"; then
            echo "âš ï¸ InstÃ¢ncia jÃ¡ estÃ¡ rodando no PM2!"

            if [[ "$INSTALL_MODE" == "update" ]]; then
                echo "ğŸ”„ Modo de atualizaÃ§Ã£o detectado"
                UPDATE_MODE=true
            else
                if [[ "$SAFE_MODE" == "true" ]]; then
                    read -p "â“ Deseja parar a instÃ¢ncia existente? (s/N): " -n 1 -r
                    echo
                    if [[ $REPLY =~ ^[Ss]$ ]]; then
                        echo "â¹ï¸ Parando instÃ¢ncia existente..."
                        pm2 stop "${instancia_add}" || echo "âš ï¸ NÃ£o foi possÃ­vel parar (pode jÃ¡ estar parada)"
                    else
                        echo "âŒ InstalaÃ§Ã£o cancelada para evitar conflitos."
                        exit 1
                    fi
                fi
            fi
        fi

        # Backup dos dados existentes
        if [[ "$AUTO_BACKUP" == "true" ]]; then
            backup_dir="/home/deploy/${instancia_add}_backup_$(date +%Y%m%d_%H%M%S)"
            echo "ğŸ’¾ Criando backup em: ${backup_dir}"
            cp -r "/home/deploy/${instancia_add}" "${backup_dir}"
            echo "âœ… Backup criado com sucesso!"
        fi
    fi

    # Verificar portas em uso
    if netstat -tuln | grep -q ":${backend_port}"; then
        echo "âš ï¸ Porta ${backend_port} jÃ¡ estÃ¡ em uso!"
        echo "Verificando se Ã© nossa aplicaÃ§Ã£o..."

        if curl -s "http://localhost:${backend_port}/health" | grep -q "healthy"; then
            echo "âœ… Application jÃ¡ estÃ¡ rodando e saudÃ¡vel!"

            if [[ "$INSTALL_MODE" != "update" ]]; then
                read -p "â“ Deseja atualizar a instalaÃ§Ã£o existente? (s/N): " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Ss]$ ]]; then
                    echo "âŒ InstalaÃ§Ã£o cancelada para evitar conflitos."
                    exit 1
                fi
                UPDATE_MODE=true
            fi
        else
            echo "âŒ Outra aplicaÃ§Ã£o estÃ¡ usando a porta!"
            echo "Por favor, pare a outra aplicaÃ§Ã£o ou mude a porta."
            exit 1
        fi
    fi

    # Verificar Node.js versÃ£o
    if command -v node >/dev/null 2>&1; then
        node_version=$(node -v)
        echo "âœ… Node.js encontrado: ${node_version}"

        # Verificar compatibilidade
        node_major=$(echo "${node_version:1}" | cut -d'.' -f1)
        if [[ $node_major -lt 16 ]]; then
            echo "âš ï¸ Node.js ${node_version} detectado - pode haver incompatibilidades"
            echo "Recomendado: Node.js 16+"
        fi
    else
        echo "â„¹ï¸ Node.js nÃ£o encontrado - serÃ¡ instalado"
    fi
}

# ğŸ“¦ BACKUP AUTOMÃTICO
create_full_backup() {
    if [[ "$AUTO_BACKUP" != "true" ]]; then
        echo "â­ï¸ Pulando criaÃ§Ã£o de backup (desativado)"
        return 0
    fi

    echo "ğŸ”„ Criando backup completo do sistema..."

    backup_name="whaticket_backup_$(date +%Y%m%d_%H%M%S)"
    backup_dir="/tmp/${backup_name}"

    mkdir -p "${backup_dir}"

    # 1. Backup da database
    if sudo -u postgres psql -lqt | grep -qw "${instancia_add}"; then
        echo "ğŸ’¾ Fazendo backup da database..."
        sudo -u postgres pg_dump "${instancia_add}" > "${backup_dir}/database.sql"
        gzip "${backup_dir}/database.sql"
    fi

    # 2. Backup dos arquivos da instÃ¢ncia
    if [[ -d "/home/deploy/${instancia_add}" ]]; then
        echo "ğŸ’¾ Fazendo backup dos arquivos da instÃ¢ncia..."
        cp -r "/home/deploy/${instancia_add}" "${backup_dir}/instance"
    fi

    # 3. Backup de configuraÃ§Ãµes
    if [[ -f "/home/deploy/${instancia_add}/backend/.env" ]]; then
        cp "/home/deploy/${instancia_add}/backend/.env" "${backup_dir}/.env"
    fi

    # 4. Backup do PM2
    pm2 save

    echo "âœ… Backup completo criado em: ${backup_dir}"
    echo "Para restaurar: sudo rsync -a ${backup_dir}/instance/ /home/deploy/${instancia_add}/"
}

# ğŸš¨ VALIDAÃ‡ÃƒO PÃ“S-INSTALAÃ‡ÃƒO
validate_installation() {
    if [[ "$SAFE_MODE" != "true" ]]; then
        echo "âš¡ Modo rÃ¡pido - pulando validaÃ§Ã£o detalhada"
        return 0
    fi

    echo "ğŸ” Validando instalaÃ§Ã£o..."

    local errors=0

    # 1. Verificar se services estÃ£o rodando
    if ! pm2 list | grep -q "${instancia_add}.*online"; then
        echo "âŒ Backend nÃ£o estÃ¡ rodando no PM2"
        ((errors++))
    else
        echo "âœ… Backend estÃ¡ rodando no PM2"
    fi

    # 2. Verificar se porta estÃ¡ respondendo
    sleep 5
    if ! curl -s "http://localhost:${backend_port}/health" | grep -q "healthy"; then
        echo "âŒ Backend nÃ£o estÃ¡ respondendo na porta ${backend_port}"
        ((errors++))
    else
        echo "âœ… Backend estÃ¡ respondendo corretamente"
    fi

    # 3. Verificar database
    if ! sudo -u postgres psql -d "${instancia_add}" -c "SELECT 1" >/dev/null 2>&1; then
        echo "âŒ Database nÃ£o estÃ¡ acessÃ­vel"
        ((errors++))
    else
        echo "âœ… Database estÃ¡ acessÃ­vel"
    fi

    # 4. Verificar Redis
    if docker exec "redis-${instancia_add}" redis-cli ping >/dev/null 2>&1; then
        echo "âœ… Redis estÃ¡ respondendo"
    else
        echo "âš ï¸ Redis nÃ£o estÃ¡ respondendo (pode ser normal se nÃ£o estiver sendo usado)"
    fi

    # 5. Verificar logs de erros
    backend_errors=$(pm2 logs "${instancia_add}" --lines 50 --err 2>/dev/null | grep -c "ERROR\|FATAL" || echo "0")
    if [[ $backend_errors -gt 0 ]]; then
        echo "âš ï¸ Encontrados ${backend_errors} erros no backend - verifique os logs"
    fi

    if [[ $errors -gt 0 ]]; then
        echo ""
        echo "âŒ InstalaÃ§Ã£o concluÃ­da com ${errors} erros!"
        echo "Verifique os logs para mais detalhes:"
        echo "  pm2 logs ${instancia_add}"
        echo "  sudo journalctl -u nginx"
        return 1
    else
        echo ""
        echo "âœ… InstalaÃ§Ã£o validada com sucesso!"
        return 0
    fi
}

# ğŸ”„ ROLLBACK EM CASO DE PROBLEMAS
rollback_installation() {
    echo "ğŸ”„ Executando rollback da instalaÃ§Ã£o..."

    # Parar serviÃ§os
    pm2 stop "${instancia_add}" 2>/dev/null || true
    sudo systemctl stop nginx 2>/dev/null || true

    # Restaurar backup se existir
    latest_backup=$(ls -t /tmp/whaticket_backup_* 2>/dev/null | head -1)
    if [[ ! -z "$latest_backup" ]]; then
        echo "ğŸ’¾ Restaurando do backup: ${latest_backup}"

        # Restaurar database
        if [[ -f "${latest_backup}/database.sql.gz" ]]; then
            gunzip -c "${latest_backup}/database.sql.gz" | sudo -u postgres psql "${instancia_add}"
        fi

        # Restaurar arquivos
        if [[ -d "${latest_backup}/instance" ]]; then
            sudo rm -rf "/home/deploy/${instancia_add}" 2>/dev/null || true
            sudo cp -r "${latest_backup}/instance" "/home/deploy/"
            sudo chown -R deploy:deploy "/home/deploy/${instancia_add}"
        fi

        echo "âœ… Rollback concluÃ­do!"
    else
        echo "âš ï¸ Nenhum backup encontrado para restaurar"
    fi

    # Reiniciar serviÃ§os do estado anterior
    sudo systemctl start nginx 2>/dev/null || true
    pm2 resurrect 2>/dev/null || true
}

# Criar scripts de manutenÃ§Ã£o
create_maintenance_scripts() {
    echo "ğŸ”§ Configurando scripts de manutenÃ§Ã£o..."
    printf "\n\n"

    # Criar diretÃ³rio de scripts
    mkdir -p /home/deploy/${instancia_add}/scripts
    chown deploy:deploy /home/deploy/${instancia_add}/scripts

    # Copiar script de verificaÃ§Ã£o
    chmod +x "${PROJECT_ROOT}"/utils/verify_installation.sh
    cp "${PROJECT_ROOT}"/utils/verify_installation.sh /home/deploy/${instancia_add}/scripts/

    # Criar script de correÃ§Ã£o do frontend
    cat > /home/deploy/${instancia_add}/scripts/fix_frontend.sh << 'EOF'
#!/bin/bash
# Script de correÃ§Ã£o do frontend
# Resolve problemas de build e index.html

cd "$(dirname "$0")/.."
INSTANCE_DIR="$(pwd)"

echo "ğŸ”§ Corrigindo frontend do WhatTicket Plus..."
echo "InstÃ¢ncia: $(basename "$INSTANCE_DIR")"

cd frontend

# Configurar ambiente
export NODE_ENV=production
export GENERATE_SOURCEMAP=false
export CI=false
export NODE_OPTIONS="--max-old-space-size=6144"

# Verificar se build existe
if [[ -f "build/index.html" ]]; then
    file_size=$(stat -c%s "build/index.html" 2>/dev/null || echo "0")
    if [[ "$file_size" -gt 1000 ]]; then
        echo "âœ… Build jÃ¡ estÃ¡ funcionando ($file_size bytes)"
        exit 0
    fi
fi

echo "ğŸ—ï¸ Reconstruindo frontend..."
npm cache clean --force
rm -rf build/* node_modules/.cache .eslintcache 2>/dev/null || true
npm install --production=false
npm run build

if [[ -f "build/index.html" ]]; then
    file_size=$(stat -c%s "build/index.html" 2>/dev/null || echo "0")
    if [[ "$file_size" -gt 1000 ]]; then
        echo "âœ… Frontend corrigido com sucesso ($file_size bytes)"
        chmod -R 755 build/
        chown -R deploy:deploy build/ 2>/dev/null || true

        # Reiniciar serviÃ§os
        sudo systemctl restart $(basename "$INSTANCE_DIR") 2>/dev/null || true
        pm2 restart all 2>/dev/null || true

        echo "ğŸ‰ CorreÃ§Ã£o concluÃ­da!"
    else
        echo "âŒ Falha na correÃ§Ã£o do frontend"
        exit 1
    fi
else
    echo "âŒ Build falhou completamente"
    exit 1
fi
EOF

    chmod +x /home/deploy/${instancia_add}/scripts/fix_frontend.sh
    chown deploy:deploy /home/deploy/${instancia_add}/scripts/fix_frontend.sh

    # Criar script de backup
    cat > /home/deploy/${instancia_add}/scripts/backup.sh << EOF
#!/bin/bash
# Script de backup automatizado

cd "\$(dirname "\$0")/.."
INSTANCE_DIR="\$(pwd)"
INSTANCE_NAME="\$(basename "\$INSTANCE_DIR")"

echo "ğŸ’¾ Criando backup da instÃ¢ncia: \$INSTANCE_NAME"

BACKUP_NAME="\${INSTANCE_NAME}_backup_\$(date +%Y%m%d_%H%M%S)"
BACKUP_DIR="/tmp/\${BACKUP_NAME}"

mkdir -p "\$BACKUP_DIR"

# Backup da database
if sudo -u postgres psql -lqt | grep -qw "\$INSTANCE_NAME"; then
    echo "ğŸ’¾ Fazendo backup da database..."
    sudo -u postgres pg_dump "\$INSTANCE_NAME" > "\$BACKUP_DIR/database.sql"
    gzip "\$BACKUP_DIR/database.sql"
fi

# Backup dos arquivos
echo "ğŸ’¾ Fazendo backup dos arquivos..."
cp -r "\$INSTANCE_DIR" "\$BACKUP_DIR/instance"

# Comprimir backup completo
cd /tmp
tar -czf "\${BACKUP_NAME}.tar.gz" "\$BACKUP_NAME"
rm -rf "\$BACKUP_DIR"

echo "âœ… Backup criado: /tmp/\${BACKUP_NAME}.tar.gz"
EOF

    chmod +x /home/deploy/${instancia_add}/scripts/backup.sh
    chown deploy:deploy /home/deploy/${instancia_add}/scripts/backup.sh

    # Criar script de atualizaÃ§Ã£o
    cat > /home/deploy/${instancia_add}/scripts/update.sh << 'EOF'
#!/bin/bash
# Script de atualizaÃ§Ã£o da instÃ¢ncia

cd "$(dirname "$0")/.."
INSTANCE_DIR="$(pwd)"
INSTANCE_NAME="$(basename "$INSTANCE_DIR")"

echo "ğŸ”„ Atualizando instÃ¢ncia: $INSTANCE_NAME"

# Parar serviÃ§os
echo "â¹ï¸ Parando serviÃ§os..."
pm2 stop "$INSTANCE_NAME" 2>/dev/null || true

# Fazer backup antes de atualizar
./scripts/backup.sh

# Atualizar cÃ³digo
echo "ğŸ“¥ Atualizando cÃ³digo..."
cd "$INSTANCE_DIR"
git pull origin main

# Atualizar backend
echo "ğŸ”§ Atualizando backend..."
cd backend
npm install
npm run build
npm run db:migrate

# Atualizar frontend
echo "ğŸ¨ Atualizando frontend..."
cd ../frontend
npm install --production=false
npm run build

# Reiniciar serviÃ§os
echo "â–¶ï¸ Reiniciando serviÃ§os..."
cd "$INSTANCE_DIR"
pm2 start "$INSTANCE_NAME"

echo "âœ… AtualizaÃ§Ã£o concluÃ­da!"
EOF

    chmod +x /home/deploy/${instancia_add}/scripts/update.sh
    chown deploy:deploy /home/deploy/${instancia_add}/scripts/update.sh

    echo "âœ… Scripts de manutenÃ§Ã£o criados em: /home/deploy/${instancia_add}/scripts/"
}

# â”€â”€â”€ EXECUÃ‡ÃƒO PRINCIPAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Mostrar menu de opÃ§Ãµes
show_menu

echo ""
echo "ğŸš€ Iniciando instalaÃ§Ã£o no modo: $INSTALL_MODE"
echo ""

# 1. VerificaÃ§Ã£o de seguranÃ§a (se aplicÃ¡vel)
if [[ "$SAFE_MODE" == "true" ]] || [[ "$UPDATE_MODE" == "true" ]]; then
    check_existing_installation

    # Pergunta sobre backup (se nÃ£o for automÃ¡tico)
    if [[ "$AUTO_BACKUP" != "true" ]]; then
        read -p "ğŸ’¾ Deseja criar backup completo antes de prosseguir? (S/n): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            create_full_backup
        fi
    else
        create_full_backup
    fi
fi

# 2. VerificaÃ§Ã£o de compatibilidade (se nÃ£o pular)
if [[ "$SKIP_VALIDATION" != "true" ]]; then
    if [[ -f "${PROJECT_ROOT}"/lib/_system_ubuntu22.sh ]]; then
        ubuntu_compatibility_check
    fi
fi

# 3. ConfiguraÃ§Ãµes interativas (se nÃ£o for atualizaÃ§Ã£o)
if [[ "$UPDATE_MODE" != "true" ]]; then
    inquiry_options
fi

# 4. Sistema base (dependÃªncias)
echo ""
print_banner
printf "${WHITE} ğŸ”§ Instalando dependÃªncias do sistema...${GRAY_LIGHT}\n"
system_update
system_node_install
system_pm2_install
system_docker_install
system_puppeteer_dependencies
system_snapd_install
system_nginx_install
system_certbot_install

# 5. Sistema config
system_create_user

# 6. Backend
echo ""
print_banner
printf "${WHITE} ğŸ”§ Configurando backend...${GRAY_LIGHT}\n"
system_git_clone
backend_set_env
backend_redis_create
backend_node_dependencies

# 7. Database e MigraÃ§Ãµes
echo ""
print_banner
printf "${WHITE} ğŸ—„ï¸ Configurando database...${GRAY_LIGHT}\n"

if ! sudo -u postgres psql -lqt | grep -qw "${instancia_add}"; then
    # Criar database nova
    sudo su - postgres <<EOF
    createdb ${instancia_add};
    psql
    CREATE USER ${instancia_add} SUPERUSER INHERIT CREATEDB CREATEROLE;
    ALTER USER ${instancia_add} PASSWORD '${mysql_root_password}';
    \q
    exit
EOF
fi

# Build e migraÃ§Ãµes
backend_node_build

# Executar migrations com validaÃ§Ã£o
echo "ğŸ”„ Executando migrations..."
if ! npm run db:migrate; then
    echo "âŒ Erro nas migraÃ§Ãµes!"
    if [[ "$SAFE_MODE" == "true" ]]; then
        read -p "Deseja fazer rollback para o estado anterior? (S/n): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            rollback_installation
            exit 1
        fi
    fi
fi

# Seed com validaÃ§Ã£o
if ! npm run db:seed; then
    echo "âš ï¸ Erro no seed - pode ser normal se jÃ¡ existe dados"
fi

backend_start_pm2

# 8. Frontend
echo ""
print_banner
printf "${WHITE} ğŸ¨ Configurando frontend...${GRAY_LIGHT}\n"
frontend_set_env
frontend_node_dependencies
frontend_node_build
frontend_start_pm2

# 9. Network (Configurar Nginx PRIMEIRO)
echo ""
print_banner
printf "${WHITE} ğŸŒ Configurando rede...${GRAY_LIGHT}\n"
system_nginx_conf

# 10. Configurar server blocks do Nginx ANTES do Certbot
echo ""
print_banner
printf "${WHITE} ğŸŒ Configurando server blocks Nginx...${GRAY_LIGHT}\n"
backend_nginx_setup
frontend_nginx_setup

# 11. Reiniciar Nginx para aplicar as configuraÃ§Ãµes
system_nginx_restart

# 12. AGORA configurar SSL com Certbot
echo ""
print_banner
printf "${WHITE} ğŸ”’ Configurando SSL com Certbot...${GRAY_LIGHT}\n"
system_certbot_setup

# 10. Scripts de manutenÃ§Ã£o
create_maintenance_scripts

# 11. ValidaÃ§Ã£o final
echo ""
print_banner
printf "${WHITE} ğŸ” Validando instalaÃ§Ã£o...${GRAY_LIGHT}\n"

if validate_installation; then
    echo ""
    print_banner
    printf "${WHITE} âœ… INSTALAÃ‡ÃƒO CONCLUÃDA COM SUCESSO!${GRAY_LIGHT}"
    printf "\n\n"
    printf "${WHITE} ğŸŒ Acesse: ${frontend_url}${GRAY_LIGHT}"
    printf "\n"
    printf "${WHITE} ğŸ‘¤ UsuÃ¡rio: ${deploy_password}${GRAY_LIGHT}"
    printf "\n"
    printf "${WHITE} ğŸ”§ Scripts: /home/deploy/${instancia_add}/scripts/${GRAY_LIGHT}"
    printf "\n"
    printf "${WHITE} ğŸ“¦ Backup: ${AUTO_BACKUP}${GRAY_LIGHT}"
    printf "\n"
    printf "${WHITE} ğŸ”’ Modo Seguro: ${SAFE_MODE}${GRAY_LIGHT}"
    printf "\n\n"

    echo "ğŸ› ï¸ Scripts disponÃ­veis:"
    echo "  â€¢ /home/deploy/${instancia_add}/scripts/fix_frontend.sh - Corrigir problemas do frontend"
    echo "  â€¢ /home/deploy/${instancia_add}/scripts/backup.sh - Fazer backup completo"
    echo "  â€¢ /home/deploy/${instancia_add}/scripts/update.sh - Atualizar instÃ¢ncia"
    echo "  â€¢ /home/deploy/${instancia_add}/scripts/verify_installation.sh - Verificar instalaÃ§Ã£o"
    echo ""

else
    echo ""
    echo "âŒ Ocorreram erros na instalaÃ§Ã£o!"
    echo ""
    if [[ "$SAFE_MODE" == "true" ]]; then
        read -p "Deseja fazer rollback automÃ¡tico? (S/n): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            rollback_installation
        fi
    fi

    echo "Verifique os logs para mais detalhes:"
    echo "  pm2 logs ${instancia_add}"
    echo "  sudo journalctl -u nginx"
    exit 1
fi